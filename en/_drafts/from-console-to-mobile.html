---
layout: post-en
title:  "From console to mobile"
date:   2015-07-20 18:31:38
author: Antonio Feregrino Bola√±os
categories: xamarin
excerpt: I've decided to kill my old blog, if you ever visit [blog.fferegrino.org] again you'll find that it isn't what it used to be. I decided to divide the content and if you came here looking for technical stuff, this is the right place.
lang: en
---
At school I was often asked to write small console apps to practice programming concepts, and some teachers even wanted a fully functional project in such at way.  
<br />
But what happens when we face real people/world problems? for sure, there are still console apps out in the wild, but nowadays all the successful applications have a mobile version, why yours shouldn't have one.

In this post I'll try to show you how to go from console to mobile (using Xamarin.Forms) with a simple example, it's a bit long but I'll make it worth the reading.

<h3>Console</h3>
I'd like to start by introducing the app that we'll transform to mobile, this app takes two strings and returns a number indicating the "distance" between them using the <a href="http://www.dotnetperls.com/levenshtein" target="_blank">Levenshtein distance algorithm</a>, for example:
<table>
	<thead>
		<tr>
			<td>str1</td>
			<td>str2</td>
			<td>Distance</td>	
		</tr>
	</thead>
	<tr>
		<td>ant</td>
		<td>aunt</td>
		<td>1</td>
	</tr>
	<tr>
		<td>Samantha</td>
		<td>Sam</td>
		<td>5</td>
	</tr>
	<tr>
		<td>Xamarin</td>
		<td>Samaryn</td>
		<td>2</td>
	</tr>
</table>
I'll use the implementation from Dot Net Perls, which is a nice static method that we can easily call in our program. Now, in a console app we ask the user for input with <code>Console.ReadLine()</code> in this case we'd use something like this: 
{% highlight csharp	%}
static void Main()
{
	Console.WriteLine("First string:");
	string str1 = Console.ReadLine();
	Console.WriteLine("Second string:");
	string str2 = Console.ReadLine();
	int distance = Compute(str1, str2);
	Console.WriteLine("Distance: " + distance);
}
{% endhighlight %}
<h3>Some differences</h3>
<h4>Entry point</h4>
As we have seen before, our program has an entry point (the <code>Main</code> method) whereas for mobile every platform has its own entry point, not necesarily a Main method. Other important thing is that  for a console app we tend to write most of the application logic inside the entry method, while the entry method for a mobile application runs code that usually isn't user provided code.
<h4>Controls</h4>
A thing that our users are looking for is having a nice UI to interact with the app, in the console user must interact secuentially, in our example a user that has entered the first string cannot go back to modify it. Or think about what happens if for some reason the user wants to type the second string before the first one? In a mobile app we can solve this problem by using controls, with them we can forget about Console writing or reading.
<br />
A control is one of the many ways to receive user interaction or to provide feedback to the user about what is happening. In our example we will replace both <code>Console.ReadLine</code> for a pair of <code>Entry</code> controls and the <code>Console.WriteLine</code>s for <code>Label</code>s. The controls are available for user interaction at any time.
<h4>Event oriented programming</h4>
There are few user interactions that we can handle when programming a console applications, the user can only enter text, use the keyboard arrows or press the enter key. On the other hand if we use controls in our mobile app a whole lot of user interactions can be made. When a user interacts with a control an event is fired, we as programmers provide code to handle such events. We call that "event oriented programming" since the behaviour of our app is driven by the events we choose to handle.
<h3>Xamarin.Forms</h3>
So, what is Xamarin.Forms? in a few words it is a tool provided by the Xamarin Platforms that allows us to share even more code when writing an app. Xamarin.Forms (I'll be calling it just "Forms" from now on) provides a set of common controls to write our application interface once and have it work on the three major mobile platforms. The controls we create using Forms are rendered to platform specific controls in order to take advantage of each operating system capabilities. For example: if we develop using the traditional approach we must work on the UI three times (each for every operating system).  
<br />
<br />
As I mentioned before, the Levenshtein app will have two text input boxes, three labels and one button. If we had choosen the traditional approach we'll had to write six text input boxes (two for each platform), three buttons (again, one for each platform). Look at the table below to see what the controls we'll be using render to:
<table>
	<thead>
		<tr>
			<td>Forms</td>
			<td>Android</td>
			<td>iOS</td>	
			<td>Windows Phone</td>	
		</tr>
	</thead>
	<tr>
		<td>Button</td>
		<td>Button (View)</td>
		<td>UIButton (UIControl)</td>	
		<td>Button (Control)</td>	
	</tr>
	<tr>
		<td>Label</td>
		<td>TextView (View)</td>
		<td>UILabel (UIControl)</td>	
		<td>TextBlock (Control)</td>	
	</tr>
	<tr>
		<td>Entry</td>
		<td>EditText (View)</td>
		<td>UITextField (UIControl)</td>	
		<td>TextBox (Control)</td>	
	</tr>
</table>
<h3>Actual code</h3>
